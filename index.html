<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flowkey Notes Parser & Printer</title>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          Cantarell, sans-serif;
        margin: 0;
        padding: 20px;
        background: #f5f5f5;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #333;
        margin-top: 0;
      }

      .input-section {
        margin-bottom: 30px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #555;
      }

      textarea {
        width: 100%;
        min-height: 150px;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 4px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
      }

      textarea:focus {
        outline: none;
        border-color: #4caf50;
      }

      .controls {
        display: flex;
        gap: 15px;
        align-items: flex-end;
        margin-bottom: 20px;
      }

      .input-group {
        flex: 1;
      }

      input[type="text"],
      input[type="number"] {
        width: 100%;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
      }

      input:focus {
        outline: none;
        border-color: #4caf50;
      }

      button {
        padding: 12px 24px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.3s;
      }

      button:hover {
        background: #45a049;
      }

      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .status {
        padding: 12px;
        border-radius: 4px;
        margin-bottom: 20px;
        display: none;
      }

      .status.info {
        display: block;
        background: #e3f2fd;
        color: #1976d2;
      }

      .status.error {
        display: block;
        background: #ffebee;
        color: #c62828;
      }

      .status.success {
        display: block;
        background: #e8f5e9;
        color: #2e7d32;
      }

      .preview-section {
        margin-top: 30px;
      }

      .sheet-container {
        background: white;
        padding: 20px;
        border-radius: 4px;
      }

      .sheet-row {
        margin-bottom: 20px;
        page-break-inside: avoid;
        width: 100%;
      }

      .sheet-row-image {
        display: block;
        width: 100%;
        height: auto;
      }

      .loading {
        text-align: center;
        padding: 40px;
        color: #666;
      }

      .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #4caf50;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      @media print {
        body {
          background: white;
          padding: 0;
          margin: 0;
        }

        .container {
          box-shadow: none;
          padding: 0;
          margin: 0;
          max-width: 100%;
        }

        .input-section,
        .controls,
        .status,
        h1,
        h2,
        button {
          display: none !important;
        }

        .preview-section {
          margin: 0 !important;
        }

        .sheet-container {
          border: none;
          padding: 0;
          margin: 0;
        }

        .sheet-row {
          page-break-inside: avoid;
          margin: 0;
          padding: 0;
          border: none;
          width: 100%;
        }

        .sheet-row-image {
          display: block;
          width: 100%;
          height: auto;
          margin: 0;
          padding: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Flowkey Notes Parser & Printer</h1>

      <div class="input-section">
        <label for="htmlInput">Paste Flowkey HTML content:</label>
        <textarea
          id="htmlInput"
          placeholder="Paste the HTML content containing sheet-image divs..."
        ></textarea>
      </div>

      <div class="controls">
        <div class="input-group">
          <label for="blocksPerRow">Blocks per Row:</label>
          <input type="number" id="blocksPerRow" value="4" min="1" max="16" />
        </div>
        <button id="parseBtn">Parse & Preview</button>
        <button id="printBtn" disabled>Print</button>
      </div>

      <div id="status" class="status"></div>

      <div class="preview-section" id="previewSection" style="display: none">
        <h2>Preview</h2>
        <div id="sheetContainer" class="sheet-container"></div>
      </div>
    </div>

    <script>
      const htmlInput = document.getElementById("htmlInput");
      const blocksPerRowInput = document.getElementById("blocksPerRow");
      const parseBtn = document.getElementById("parseBtn");
      const printBtn = document.getElementById("printBtn");
      const statusDiv = document.getElementById("status");
      const previewSection = document.getElementById("previewSection");
      const sheetContainer = document.getElementById("sheetContainer");

      function showStatus(message, type = "info") {
        statusDiv.textContent = message;
        statusDiv.className = `status ${type}`;
      }

      function hideStatus() {
        statusDiv.className = "status";
      }

      function parseHTML(htmlContent) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, "text/html");
        const sheetImages = doc.querySelectorAll(".sheet-image");

        const images = [];

        sheetImages.forEach((img) => {
          const style = img.getAttribute("style");
          const urlMatch = style.match(/url\(['"](.*?)['"]\)/);
          const widthMatch = style.match(/width:\s*(\d+)px/);
          const leftMatch = style.match(/left:\s*(\d+)px/);
          const topMatch = style.match(/top:\s*([-\d]+)px/);

          if (urlMatch && widthMatch && leftMatch) {
            images.push({
              url: urlMatch[1],
              width: parseInt(widthMatch[1]),
              left: parseInt(leftMatch[1]),
              top: topMatch ? parseInt(topMatch[1]) : 0,
            });
          }
        });

        return images.sort((a, b) => a.left - b.left);
      }

      async function loadImage(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = url;
        });
      }

      async function loadAllImages(imageData) {
        showStatus("Loading images...", "info");
        const images = [];

        for (let i = 0; i < imageData.length; i++) {
          try {
            const img = await loadImage(imageData[i].url);
            images.push({
              ...imageData[i],
              element: img,
              height: img.height,
              width: img.width,
            });
            showStatus(
              `Loading images... ${i + 1}/${imageData.length}`,
              "info",
            );
          } catch (error) {
            console.error(`Failed to load image ${i}:`, error);
            showStatus(`Failed to load image ${i + 1}`, "error");
          }
        }

        return images;
      }

      function combineImages(images) {
        if (images.length === 0) return null;

        const canvas = document.createElement("canvas");
        const totalWidth = images.reduce((sum, img) => sum + img.width, 0);

        const minTop = Math.min(...images.map((img) => img.top));
        const maxBottom = Math.max(
          ...images.map((img) => img.top + img.height),
        );
        const totalHeight = maxBottom - minTop;

        canvas.width = totalWidth;
        canvas.height = totalHeight;

        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let currentX = 0;
        images.forEach((img) => {
          ctx.drawImage(img.element, currentX, 0);
          currentX += img.width;
        });

        return { canvas, ctx };
      }

      function detectBarLines(canvas, ctx) {
        const width = canvas.width;
        const height = canvas.height;
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // Check for continuous vertical lines (bar lines must be tall)
        const verticalScores = [];

        for (let x = 0; x < width; x++) {
          let longestDarkStreak = 0;
          let currentStreak = 0;
          let totalDarkPixels = 0;
          let totalSamples = 0;

          // Sample points along the height, focusing on staff area
          const startY = Math.floor(height * 0.2);
          const endY = Math.floor(height * 0.8);
          const sampledHeight = endY - startY;

          for (let y = startY; y < endY; y++) {
            const idx = (y * width + x) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            const brightness = (r + g + b) / 3;

            if (brightness < 128) {
              currentStreak++;
              totalDarkPixels++;
              longestDarkStreak = Math.max(longestDarkStreak, currentStreak);
            } else {
              currentStreak = 0;
            }
            totalSamples++;
          }

          // Score based on both continuity (longest streak) and density
          const continuityScore = longestDarkStreak / sampledHeight; // How tall is the continuous line
          const densityScore = totalDarkPixels / totalSamples; // Overall darkness

          // A bar line should have both high continuity and density
          const score = continuityScore * 0.7 + densityScore * 0.3;
          verticalScores.push({
            score,
            continuity: continuityScore,
            density: densityScore,
          });
        }

        // Find bar lines (tall continuous vertical lines)
        const barLines = [];
        const scoreThreshold = 0.4; // Combined score threshold
        const continuityThreshold = 0.5; // Must span at least 50% of height continuously
        const minBarWidth = 1;
        const maxBarWidth = 6; // Maximum width for a bar line
        const minBarDistance = 100; // Minimum distance between bars (increased)

        let inBar = false;
        let barStart = 0;

        for (let x = 0; x < width; x++) {
          const { score, continuity } = verticalScores[x];

          // Check if this is a potential bar line (must meet both thresholds)
          const isBarLine =
            score > scoreThreshold && continuity > continuityThreshold;

          if (isBarLine && !inBar) {
            barStart = x;
            inBar = true;
          } else if (!isBarLine && inBar) {
            const barWidth = x - barStart;
            if (barWidth >= minBarWidth && barWidth <= maxBarWidth) {
              const barCenter = Math.floor((barStart + x) / 2);

              // Check if this bar is far enough from the last one
              if (
                barLines.length === 0 ||
                barCenter - barLines[barLines.length - 1] >= minBarDistance
              ) {
                barLines.push(barCenter);
              }
            }
            inBar = false;
          } else if (inBar && x - barStart > maxBarWidth) {
            // Bar is too wide, probably not a bar line
            inBar = false;
          }
        }

        return barLines;
      }

      function splitByBarLines(canvas, ctx, barLines) {
        const height = canvas.height;
        const blocks = [];

        // Always include start and end
        const splitPoints = [0, ...barLines, canvas.width];

        for (let i = 0; i < splitPoints.length - 1; i++) {
          const startX = splitPoints[i];
          const endX = splitPoints[i + 1];
          const width = endX - startX;

          if (width > 10) {
            // Minimum block width
            blocks.push({
              startX: startX,
              endX: endX,
              width: width,
              height: height,
            });
          }
        }

        return blocks;
      }

      function validateAndMergeBlocks(canvas, blocks) {
        if (blocks.length === 0) return [];

        // Calculate average and median width to determine if blocks are similar
        const widths = blocks.map((b) => b.width);
        const avgWidth = widths.reduce((sum, w) => sum + w, 0) / widths.length;
        const sortedWidths = [...widths].sort((a, b) => a - b);
        const medianWidth = sortedWidths[Math.floor(sortedWidths.length / 2)];

        // Use median as reference (more robust to outliers)
        const referenceWidth = medianWidth;

        // Blocks should be within 40% of the reference width
        const minAcceptableWidth = referenceWidth * 0.6;
        const maxAcceptableWidth = referenceWidth * 1.4;

        // Very narrow blocks (like double bar lines) should always be merged
        const veryNarrowThreshold = referenceWidth * 0.3;

        const validatedBlocks = [];
        let i = 0;

        while (i < blocks.length) {
          let currentBlock = blocks[i];

          // If block is too narrow, try to merge with next blocks
          while (
            currentBlock.width < minAcceptableWidth &&
            i < blocks.length - 1
          ) {
            i++;
            const nextBlock = blocks[i];
            currentBlock = {
              startX: currentBlock.startX,
              endX: nextBlock.endX,
              width: nextBlock.endX - currentBlock.startX,
              height: currentBlock.height,
            };
          }

          // If block is too wide, it might be a wrong detection - keep it but flag it
          if (currentBlock.width > maxAcceptableWidth * 2) {
            // This is likely multiple measures merged - split it in half
            const midPoint = Math.floor(
              (currentBlock.startX + currentBlock.endX) / 2,
            );
            validatedBlocks.push({
              startX: currentBlock.startX,
              endX: midPoint,
              width: midPoint - currentBlock.startX,
              height: currentBlock.height,
            });
            validatedBlocks.push({
              startX: midPoint,
              endX: currentBlock.endX,
              width: currentBlock.endX - midPoint,
              height: currentBlock.height,
            });
          } else {
            validatedBlocks.push(currentBlock);
          }

          i++;
        }

        // Second pass: merge very narrow blocks backward (handles end-of-sheet double bar lines)
        const mergedBlocks = [];
        for (let i = 0; i < validatedBlocks.length; i++) {
          const currentBlock = validatedBlocks[i];

          // If this block is very narrow and we have a previous block, merge it backward
          if (
            currentBlock.width < veryNarrowThreshold &&
            mergedBlocks.length > 0
          ) {
            const previousBlock = mergedBlocks[mergedBlocks.length - 1];
            // Extend the previous block to include this narrow one
            previousBlock.endX = currentBlock.endX;
            previousBlock.width = previousBlock.endX - previousBlock.startX;
          } else {
            mergedBlocks.push(currentBlock);
          }
        }

        // Calculate average width of middle blocks (excluding first and last)
        let targetWidth;
        let leftMargin = 0;
        let rightMargin = 0;

        if (mergedBlocks.length > 2) {
          // Calculate average of middle blocks only (pure music measures)
          const middleBlocks = mergedBlocks.slice(1, -1);
          const middleWidths = middleBlocks.map((b) => b.width);
          const avgMiddleWidth =
            middleWidths.reduce((sum, w) => sum + w, 0) / middleWidths.length;
          targetWidth = avgMiddleWidth;

          // Calculate margins (difference between first/last and average)
          const firstBlock = mergedBlocks[0];
          leftMargin = Math.max(0, firstBlock.width - targetWidth);

          const lastBlock = mergedBlocks[mergedBlocks.length - 1];
          rightMargin = Math.max(0, lastBlock.width - targetWidth);
        } else {
          // Not enough blocks, use median
          const mergedWidths = mergedBlocks.map((b) => b.width);
          const sortedMergedWidths = [...mergedWidths].sort((a, b) => a - b);
          targetWidth =
            sortedMergedWidths[Math.floor(sortedMergedWidths.length / 2)];
        }

        // Get canvas height for block creation
        const height = canvas.height;

        // Extract clef image if first block has extra width
        let clefCanvas = null;
        if (leftMargin > 0 && mergedBlocks.length > 0) {
          const firstBlock = mergedBlocks[0];
          clefCanvas = document.createElement("canvas");
          clefCanvas.width = leftMargin;
          clefCanvas.height = height;

          const clefCtx = clefCanvas.getContext("2d");
          clefCtx.fillStyle = "white";
          clefCtx.fillRect(0, 0, leftMargin, height);

          // Extract the left portion (clef/key signature) from the first block
          clefCtx.drawImage(
            canvas,
            firstBlock.startX,
            0,
            leftMargin,
            height,
            0,
            0,
            leftMargin,
            height,
          );
        }

        // Create blocks: first and last ALWAYS keep original width, middle blocks normalized
        const finalBlocks = [];

        for (let i = 0; i < mergedBlocks.length; i++) {
          const block = mergedBlocks[i];
          const blockCanvas = document.createElement("canvas");

          // First and last blocks keep original size, middle blocks normalized
          const isFirst = i === 0;
          const isLast = i === mergedBlocks.length - 1;

          let blockWidth;
          if (mergedBlocks.length > 2 && (isFirst || isLast)) {
            blockWidth = block.width; // Keep original width
          } else {
            blockWidth = targetWidth; // Normalize
          }

          blockCanvas.width = blockWidth;
          blockCanvas.height = height;

          const blockCtx = blockCanvas.getContext("2d");
          blockCtx.fillStyle = "white";
          blockCtx.fillRect(0, 0, blockWidth, height);

          // Draw WITHOUT scaling - keep at original size
          blockCtx.drawImage(
            canvas,
            block.startX,
            0,
            block.width,
            height,
            0,
            0,
            blockWidth,
            height,
          );

          finalBlocks.push({
            canvas: blockCanvas,
            width: blockWidth,
            height: height,
          });
        }

        return { blocks: finalBlocks, leftMargin, rightMargin, clefCanvas };
      }

      function arrangeInRows(
        blocks,
        blocksPerRow,
        leftMargin,
        rightMargin,
        clefCanvas,
      ) {
        const rows = [];

        for (let i = 0; i < blocks.length; i += blocksPerRow) {
          const rowBlocks = blocks.slice(i, i + blocksPerRow);
          const rowIndex = Math.floor(i / blocksPerRow);
          const totalRows = Math.ceil(blocks.length / blocksPerRow);

          // Determine margins for this row
          const isFirstRow = rowIndex === 0;
          const isLastRow = rowIndex === totalRows - 1;
          const rowLeftMargin = isFirstRow ? 0 : leftMargin;
          const rowRightMargin = isLastRow ? 0 : rightMargin;

          // Calculate total width and max height for the row
          const totalBlockWidth = rowBlocks.reduce(
            (sum, b) => sum + b.width,
            0,
          );
          const maxHeight = Math.max(...rowBlocks.map((b) => b.height));
          const rowWidth = totalBlockWidth + rowLeftMargin + rowRightMargin;

          // Create a single canvas for the entire row
          const rowCanvas = document.createElement("canvas");
          rowCanvas.width = rowWidth;
          rowCanvas.height = maxHeight;

          const rowCtx = rowCanvas.getContext("2d");
          rowCtx.fillStyle = "white";
          rowCtx.fillRect(0, 0, rowWidth, maxHeight);

          // Draw clef on the left for rows 2+ (instead of white space)
          if (!isFirstRow && clefCanvas && rowLeftMargin > 0) {
            const clefYOffset = Math.floor((maxHeight - clefCanvas.height) / 2);
            rowCtx.drawImage(clefCanvas, 0, clefYOffset);
          }

          // Draw all blocks on the row canvas
          let currentX = rowLeftMargin;
          rowBlocks.forEach((block) => {
            // Center block vertically if needed
            const yOffset = Math.floor((maxHeight - block.height) / 2);
            rowCtx.drawImage(block.canvas, currentX, yOffset);
            currentX += block.width;
          });

          rows.push({
            canvas: rowCanvas,
            width: rowWidth,
            height: maxHeight,
          });
        }

        return rows;
      }

      function renderSheet(rows) {
        sheetContainer.innerHTML = "";

        rows.forEach((row, rowIdx) => {
          const rowDiv = document.createElement("div");
          rowDiv.className = "sheet-row";

          const img = document.createElement("img");
          img.src = row.canvas.toDataURL();
          img.alt = `Row ${rowIdx}`;
          img.className = "sheet-row-image";

          rowDiv.appendChild(img);
          sheetContainer.appendChild(rowDiv);
        });

        previewSection.style.display = "block";
        printBtn.disabled = false;
      }

      parseBtn.addEventListener("click", async () => {
        const htmlContent = htmlInput.value.trim();

        if (!htmlContent) {
          showStatus("Please paste HTML content first", "error");
          return;
        }

        try {
          parseBtn.disabled = true;
          printBtn.disabled = true;
          previewSection.style.display = "none";

          showStatus("Parsing HTML...", "info");
          const imageData = parseHTML(htmlContent);

          if (imageData.length === 0) {
            showStatus("No sheet images found in the HTML", "error");
            parseBtn.disabled = false;
            return;
          }

          showStatus(`Found ${imageData.length} image segments`, "info");

          const images = await loadAllImages(imageData);

          if (images.length === 0) {
            showStatus("Failed to load any images", "error");
            parseBtn.disabled = false;
            return;
          }

          showStatus("Combining images into single sheet...", "info");
          const { canvas, ctx } = combineImages(images);

          showStatus("Detecting bar lines...", "info");
          const barLines = detectBarLines(canvas, ctx);
          showStatus(`Detected ${barLines.length} bar lines`, "info");

          showStatus("Splitting by bar lines...", "info");
          const rawBlocks = splitByBarLines(canvas, ctx, barLines);
          showStatus(`Created ${rawBlocks.length} initial blocks`, "info");

          showStatus(
            "Validating and merging blocks with similar widths...",
            "info",
          );
          const { blocks, leftMargin, rightMargin, clefCanvas } =
            validateAndMergeBlocks(canvas, rawBlocks);
          showStatus(`Validated into ${blocks.length} blocks`, "info");

          const blocksPerRow = parseInt(blocksPerRowInput.value) || 4;
          const rows = arrangeInRows(
            blocks,
            blocksPerRow,
            leftMargin,
            rightMargin,
            clefCanvas,
          );

          showStatus(
            `Arranged into ${rows.length} rows with ${blocksPerRow} blocks per row`,
            "success",
          );

          renderSheet(rows);
        } catch (error) {
          console.error("Error:", error);
          showStatus(`Error: ${error.message}`, "error");
        } finally {
          parseBtn.disabled = false;
        }
      });

      printBtn.addEventListener("click", () => {
        window.print();
      });

      htmlInput.addEventListener("paste", () => {
        setTimeout(() => {
          if (htmlInput.value.trim()) {
            showStatus(
              'HTML content pasted. Click "Parse & Preview" to process.',
              "info",
            );
          }
        }, 100);
      });
    </script>
  </body>
</html>
